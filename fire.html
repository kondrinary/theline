<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Line â€” ASCII Straight Digit Lines (Edge Bounce)</title>
  <style>
    html,body{margin:0;height:100%;background:#0025FF;overflow:hidden}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let W=0, H=0, DPR=1;

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth  * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  const DIGITS = "0123456789";

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function smoothstep(a,b,x){
    x = clamp((x-a)/(b-a), 0, 1);
    return x*x*(3-2*x);
  }

  // Bigger glyphs => fewer columns
  function computeGrid(){
    const cols = Math.max(60, Math.min(112, Math.floor(W / (12.2*DPR))));
    const cell = W / cols;
    const rows = Math.floor(H / cell);
    return { cols, rows, cell };
  }

  // Long tail + slow fade for "filling"
  const TRAIL_FADE_ALPHA = 0.020;  // smaller = slower fade, longer persistence
  const TAIL_LEN = 240;            // number of stored positions per line
  const LINE_COUNT = 14;

  // Each line: straight horizontal trajectory, bounces only at edges.
  const lines = [];
  function resetLines(){
    lines.length = 0;
    const { cols, rows } = computeGrid();
    const usedRows = new Set();

    for(let i=0;i<LINE_COUNT;i++){
      // pick a random row but avoid too much overlap
      let ry = Math.floor( (0.08 + Math.random()*0.84) * rows );
      let guard = 0;
      while(usedRows.has(ry) && guard++ < 50){
        ry = Math.floor( (0.08 + Math.random()*0.84) * rows );
      }
      usedRows.add(ry);

      const x = Math.random() * (cols-1);
      const dir = Math.random() < 0.5 ? -1 : 1;
      const speed = (0.9 + Math.random()*2.2) * cols/12; // cells per second

      lines.push({
        y: ry,
        x,
        dir,
        speed,
        history: [],
        phase: Math.random()*Math.PI*2
      });
    }
  }
  resetLines();

  // digit generator (deterministic-ish from x,y,t)
  function digitAt(xi, yi, t){
    const v = Math.sin((xi*0.33 + yi*0.19) + t*1.15) +
              Math.sin((xi*0.12 - yi*0.27) - t*0.85);
    const n = (v*0.5 + 0.5);
    return DIGITS[Math.floor(n*10) % 10];
  }

  function fadeBackground(){
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = TRAIL_FADE_ALPHA;
    ctx.fillStyle = '#0025FF';
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;
  }

  let last = performance.now();

  function frame(now){
    const dt = Math.min(0.050, (now - last) / 1000);
    last = now;

    const { cols, rows, cell } = computeGrid();

    // If rows changed a lot (resize), re-seed to avoid out-of-bounds
    if (rows < 10 || cols < 30){
      requestAnimationFrame(frame);
      return;
    }

    // Slow fade -> long tails and accumulation
    fadeBackground();

    // Big ASCII digits
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${Math.max(16, cell*1.18)}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;

    const t = now/1000;

    for(const L of lines){
      // move straight
      L.x += L.dir * L.speed * dt;

      // bounce ONLY on edges
      if (L.x <= 0){
        L.x = 0;
        L.dir = 1;
      } else if (L.x >= cols-1){
        L.x = cols-1;
        L.dir = -1;
      }

      // store position for tail
      L.history.push(L.x);
      if (L.history.length > TAIL_LEN) L.history.shift();

      // draw tail from old -> new
      const n = L.history.length;
      for(let i=0;i<n;i++){
        const xi = L.history[i];
        const age = (n-1-i) / Math.max(1, n-1);   // 0 newest .. 1 oldest
        const a = (1.0 - age);
        // make tail long & visible
        const alpha = 0.08 + 0.62*Math.pow(a, 1.35);

        // slight sparkle near head
        const headBoost = (i === n-1) ? 1.2 : 1.0;

        const gx = Math.round(xi);
        const gy = L.y;

        // keep in bounds
        if (gx < 0 || gx >= cols || gy < 0 || gy >= rows) continue;

        const ch = digitAt(gx, gy, t + L.phase);

        ctx.fillStyle = `rgba(255,255,255,${(alpha*headBoost).toFixed(3)})`;
        ctx.fillText(ch, (gx + 0.5)*cell, (gy + 0.5)*cell);
      }
    }

    requestAnimationFrame(frame);
  }

  // initial clear
  ctx.fillStyle = '#0025FF';
  ctx.fillRect(0,0,W,H);
  requestAnimationFrame(frame);

  // Rebuild lines on resize (new random each run/resize)
  let resizeTimer = null;
  addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=>{
      resetLines();
    }, 120);
  });

})();
</script>
</body>
</html>
