<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Line â€” ASCII Bloom Loop</title>
  <style>
    html,body{margin:0;height:100%;background:#0025FF;overflow:hidden}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W=0, H=0, DPR=1;

  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(innerWidth  * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
  }
  addEventListener('resize', resize);
  resize();

  const TAU = Math.PI * 2;

  // ASCII ramp from light -> dense
  const RAMP = " .,:;i1tfLCG08@";
  const rampLen = RAMP.length;

  // Loop timing
  const PERIOD = 7.2; // seconds

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function smoothstep(a,b,x){
    x = clamp((x-a)/(b-a), 0, 1);
    return x*x*(3-2*x);
  }

  function bloomCurve(p){
    // p in [0..1]
    if (p < 0.12) return smoothstep(0.00, 0.12, p) * 0.10;       // tiny start
    if (p < 0.62) return smoothstep(0.12, 0.62, p);              // open
    if (p < 0.75) return 1.0;                                    // hold
    return 1.0 - smoothstep(0.75, 1.00, p);                      // close
  }

  function frame(now){
    const t = now / 1000;
    const p = (t % PERIOD) / PERIOD;
    const bloom = bloomCurve(p); // 0..1

    // Subtle trail
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = '#0025FF';
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    // Grid
    const cols = Math.max(90, Math.min(160, Math.floor(W / (8*DPR))));
    const cell = W / cols;
    const rows = Math.floor(H / cell);

    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = `${Math.max(10, cell*0.95)}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;

    const cx = cols * 0.5;
    const cy = rows * 0.48;

    // Flower params (in "cell" units)
    const baseR = Math.min(cols, rows) * 0.16;
    const petals = 10;
    const thickness = 0.12 + 0.20*bloom; // thickness band around petal curve
    const coreR = baseR * (0.10 + 0.12*bloom);

    // Stem curve in grid coords
    const stemY0 = cy + baseR*0.70;
    const stemY1 = cy + baseR*2.25;
    const stemX0 = cx;
    const stemX1 = cx + Math.sin(t*0.6)*baseR*0.08;

    // Render
    for(let y=0; y<rows; y++){
      for(let x=0; x<cols; x++){
        // normalized coordinates in flower space
        const dx = (x - cx);
        const dy = (y - cy);
        const r  = Math.hypot(dx, dy) / baseR;
        const ang = Math.atan2(dy, dx);

        // Petal radius function (polar)
        const open = bloom;
        const petalMod = 0.65 + 0.35*Math.cos(petals*ang + Math.sin(t*0.7)*0.15);
        const rPetal = (0.35 + 0.95*open) * petalMod;

        // Petal band intensity
        const band = 1.0 - Math.abs(r - rPetal) / thickness;
        let petalI = clamp(band, 0, 1);

        // Fade petals inside/outside to avoid filling the whole disc
        petalI *= smoothstep(0.10, 0.55, r) * (1.0 - smoothstep(1.15, 1.55, r));

        // Core intensity
        const coreI = clamp(1.0 - (r / (coreR/baseR)), 0, 1) * (0.55 + 0.45*open);

        // Stem intensity (distance to bezier-ish line)
        let stemI = 0;
        if (y > stemY0 && y < stemY1){
          const ty = (y - stemY0) / (stemY1 - stemY0);
          const sx = stemX0*(1-ty) + stemX1*ty + Math.sin(ty*TAU*0.5 + t*0.4)*baseR*0.04;
          const dist = Math.abs(x - sx);
          stemI = clamp(1.0 - dist/(0.55 + 0.25*open), 0, 1) * 0.55;
        }

        // Leaves
        let leafI = 0;
        if (y > cy + baseR*1.15 && y < cy + baseR*1.65){
          const lx = cx + (dx>0?1:-1)*baseR*0.55;
          const ly = cy + baseR*1.40;
          const ld = Math.hypot(x-lx, y-ly) / (baseR*0.55);
          leafI = clamp(1.0 - ld, 0, 1) * (0.25 + 0.25*open);
        }

        // Combine
        let I = Math.max(petalI, coreI, stemI, leafI);

        if (I < 0.06) continue;

        // Choose glyph
        const idx = Math.min(rampLen-1, Math.floor(I * (rampLen-1)));
        const ch = RAMP[idx];

        // Color: petals/core white; greenery green; stem muted white
        let fill = 'rgba(255,255,255,0.85)';
        if (leafI > petalI && leafI > coreI) fill = 'rgba(97,230,53,0.45)'; // green
        else if (coreI > petalI) fill = 'rgba(97,230,53,0.55)';
        else if (stemI > petalI) fill = 'rgba(255,255,255,0.35)';

        ctx.fillStyle = fill;
        ctx.globalAlpha = 0.55 + 0.45*I;

        ctx.fillText(ch, (x + 0.5)*cell, (y + 0.5)*cell);
      }
    }

    ctx.globalAlpha = 1;
    requestAnimationFrame(frame);
  }

  // Hard clear once to avoid first-frame artifacts
  ctx.fillStyle = '#0025FF';
  ctx.fillRect(0,0,W,H);

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
